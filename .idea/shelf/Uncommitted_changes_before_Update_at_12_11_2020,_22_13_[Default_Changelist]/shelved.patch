Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(date 1605207957932)
+++ .idea/vcs.xml	(date 1605207957932)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/watcherTasks.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/watcherTasks.xml	(date 1605207957929)
+++ .idea/watcherTasks.xml	(date 1605207957929)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectTasksOptions">
+    <enabled-global>
+      <option value="go fmt" />
+    </enabled-global>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/go-imap.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/go-imap.iml	(date 1605207957913)
+++ .idea/go-imap.iml	(date 1605207957913)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="WEB_MODULE" version="4">
+  <component name="Go" enabled="true" />
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(date 1605207957925)
+++ .idea/modules.xml	(date 1605207957925)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/go-imap.iml" filepath="$PROJECT_DIR$/.idea/go-imap.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: server/conn.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package server\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"runtime/debug\"\n\t\"time\"\n\n\t\"github.com/emersion/go-imap\"\n\t\"github.com/emersion/go-imap/backend\"\n)\n\n// Conn is a connection to a client.\ntype Conn interface {\n\tio.Reader\n\n\t// Server returns this connection's server.\n\tServer() *Server\n\t// Context returns this connection's context.\n\tContext() *Context\n\t// Capabilities returns a list of capabilities enabled for this connection.\n\tCapabilities() []string\n\t// WriteResp writes a response to this connection.\n\tWriteResp(res imap.WriterTo) error\n\t// IsTLS returns true if TLS is enabled.\n\tIsTLS() bool\n\t// TLSState returns the TLS connection state if TLS is enabled, nil otherwise.\n\tTLSState() *tls.ConnectionState\n\t// Upgrade upgrades a connection, e.g. wrap an unencrypted connection with an\n\t// encrypted tunnel.\n\tUpgrade(upgrader imap.ConnUpgrader) error\n\t// Close closes this connection.\n\tClose() error\n\tWaitReady()\n\n\tInfo() *imap.ConnInfo\n\n\tsetTLSConn(*tls.Conn)\n\tsilent() *bool // TODO: remove this\n\tserve(Conn) error\n\tcommandHandler(cmd *imap.Command) (hdlr Handler, err error)\n}\n\n// Context stores a connection's metadata.\ntype Context struct {\n\t// This connection's current state.\n\tState imap.ConnState\n\t// If the client is logged in, the user.\n\tUser backend.User\n\t// If the client has selected a mailbox, the mailbox.\n\tMailbox backend.Mailbox\n\t// True if the currently selected mailbox has been opened in read-only mode.\n\tMailboxReadOnly bool\n\t// Responses to send to the client.\n\tResponses chan<- imap.WriterTo\n\t// Closed when the client is logged out.\n\tLoggedOut <-chan struct{}\n}\n\ntype conn struct {\n\t*imap.Conn\n\n\tconn      Conn // With extensions overrides\n\ts         *Server\n\tctx       *Context\n\ttlsConn   *tls.Conn\n\tcontinues chan bool\n\tupgrade   chan bool\n\tresponses chan imap.WriterTo\n\tloggedOut chan struct{}\n\tsilentVal bool\n}\n\nfunc newConn(s *Server, c net.Conn) *conn {\n\t// Create an imap.Reader and an imap.Writer\n\tcontinues := make(chan bool)\n\tr := imap.NewServerReader(nil, continues)\n\tw := imap.NewWriter(nil)\n\n\tresponses := make(chan imap.WriterTo)\n\tloggedOut := make(chan struct{})\n\n\ttlsConn, _ := c.(*tls.Conn)\n\n\tconn := &conn{\n\t\tConn: imap.NewConn(c, r, w),\n\n\t\ts: s,\n\t\tctx: &Context{\n\t\t\tState:     imap.ConnectingState,\n\t\t\tResponses: responses,\n\t\t\tLoggedOut: loggedOut,\n\t\t},\n\t\ttlsConn:   tlsConn,\n\t\tcontinues: continues,\n\t\tupgrade:   make(chan bool),\n\t\tresponses: responses,\n\t\tloggedOut: loggedOut,\n\t}\n\n\tif s.Debug != nil {\n\t\tconn.Conn.SetDebug(s.Debug)\n\t}\n\tif s.MaxLiteralSize > 0 {\n\t\tconn.Conn.MaxLiteralSize = s.MaxLiteralSize\n\t}\n\n\tgo conn.send()\n\n\treturn conn\n}\n\nfunc (c *conn) Server() *Server {\n\treturn c.s\n}\n\nfunc (c *conn) Context() *Context {\n\treturn c.ctx\n}\n\ntype response struct {\n\tresponse imap.WriterTo\n\tdone     chan struct{}\n}\n\nfunc (r *response) WriteTo(w *imap.Writer) error {\n\terr := r.response.WriteTo(w)\n\tclose(r.done)\n\treturn err\n}\n\nfunc (c *conn) setDeadline() {\n\tif c.s.AutoLogout == 0 {\n\t\treturn\n\t}\n\n\tdur := c.s.AutoLogout\n\tif dur < MinAutoLogout {\n\t\tdur = MinAutoLogout\n\t}\n\tt := time.Now().Add(dur)\n\n\tc.Conn.SetDeadline(t)\n}\n\nfunc (c *conn) WriteResp(r imap.WriterTo) error {\n\tdone := make(chan struct{})\n\tc.responses <- &response{r, done}\n\t<-done\n\tc.setDeadline()\n\treturn nil\n}\n\nfunc (c *conn) Close() error {\n\tif c.ctx.User != nil {\n\t\tc.ctx.User.Logout()\n\t}\n\n\treturn c.Conn.Close()\n}\n\n/*\nнаша\n* OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR AUTH=PLAIN] IMAP4rev1 Service Ready\n\nстарая\n* CAPABILITY PLAIN NAMESPACE AUTH=DIGEST-MD5 QUOTA IMAP4rev1 QRESYNC UNSELECT WITHIN SASL-IR\nENABLE SEARCHRES UIDPLUS CHILDREN CONDSTORE AUTH=PLAIN LITERAL+ ANNOTATION ESEARCH I18NLEVEL=1\nXCHANGEPASSWORD LOGIN\n*/\n\nfunc (c *conn) Capabilities() []string {\n\tcaps := []string{\"IMAP4rev1\", \"LITERAL+\", \"SASL-IR\", \"CHILDREN\",\n\t\t\"PLAIN\", \"AUTH=DIGEST-MD5\", \"CHILDREN\", \"NAMESPACE\", \"QUOTA\", \"QRESYNC\", \"UNSELECT\", \"WITHIN\", \"ENABLE\", \"SEARCHRES\", \"UIDPLUS\",\n\t\t\"CONDSTORE\", \"ANNOTATION\", \"ESEARCH\", \"I18NLEVEL=1\", \"XCHANGEPASSWORD\", \"LOGIN\",\n\t}\n\n\tif c.ctx.State == imap.NotAuthenticatedState {\n\t\tif !c.IsTLS() && c.s.TLSConfig != nil {\n\t\t\tcaps = append(caps, \"STARTTLS\")\n\t\t}\n\n\t\tif !c.canAuth() {\n\t\t\tcaps = append(caps, \"LOGINDISABLED\")\n\t\t} else {\n\t\t\tfor name := range c.s.auths {\n\t\t\t\tcaps = append(caps, \"AUTH=\"+name)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, ext := range c.s.extensions {\n\t\tcaps = append(caps, ext.Capabilities(c)...)\n\t}\n\n\treturn caps\n}\n\nfunc (c *conn) writeAndFlush(w imap.WriterTo) error {\n\tif err := w.WriteTo(c.Writer); err != nil {\n\t\treturn err\n\t}\n\treturn c.Writer.Flush()\n}\n\nfunc (c *conn) send() {\n\t// Send responses\n\tfor {\n\t\tselect {\n\t\tcase <-c.upgrade:\n\t\t\t// Wait until upgrade is finished.\n\t\t\tc.Wait()\n\t\tcase needCont := <-c.continues:\n\t\t\t// Send continuation requests\n\t\t\tif needCont {\n\t\t\t\tresp := &imap.ContinuationReq{Info: \"send literal\"}\n\t\t\t\tif err := c.writeAndFlush(resp); err != nil {\n\t\t\t\t\tc.Server().ErrorLog.Println(\"cannot send continuation request: \", err)\n\t\t\t\t}\n\t\t\t}\n\t\tcase res := <-c.responses:\n\t\t\t// Got a response that needs to be sent\n\t\t\t// Request to send the response\n\t\t\tif err := c.writeAndFlush(res); err != nil {\n\t\t\t\tc.Server().ErrorLog.Println(\"cannot send response: \", err)\n\t\t\t}\n\t\tcase <-c.loggedOut:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (c *conn) greet() error {\n\tc.ctx.State = imap.NotAuthenticatedState\n\n\tcaps := c.Capabilities()\n\targs := make([]interface{}, len(caps))\n\tfor i, cap := range caps {\n\t\targs[i] = imap.RawString(cap)\n\t}\n\n\tgreeting := &imap.StatusResp{\n\t\t// Type:      imap.StatusRespOk,\n\t\tCode: imap.CodeCapability,\n\t\t// Arguments: args,\n\t\t// Info:      \"IMAP4rev1 Service Ready\",\n\t}\n\n\treturn c.WriteResp(greeting)\n}\n\nfunc (c *conn) setTLSConn(tlsConn *tls.Conn) {\n\tc.tlsConn = tlsConn\n}\n\nfunc (c *conn) IsTLS() bool {\n\treturn c.tlsConn != nil\n}\n\nfunc (c *conn) TLSState() *tls.ConnectionState {\n\tif c.tlsConn != nil {\n\t\tstate := c.tlsConn.ConnectionState()\n\t\treturn &state\n\t}\n\treturn nil\n}\n\n// canAuth checks if the client can use plain text authentication.\nfunc (c *conn) canAuth() bool {\n\treturn c.IsTLS() || c.s.AllowInsecureAuth\n}\n\nfunc (c *conn) silent() *bool {\n\treturn &c.silentVal\n}\n\nfunc (c *conn) serve(conn Conn) (err error) {\n\tc.conn = conn\n\n\tdefer func() {\n\t\tc.ctx.State = imap.LogoutState\n\t\tclose(c.loggedOut)\n\t}()\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tc.WriteResp(&imap.StatusResp{\n\t\t\t\tType: imap.StatusRespBye,\n\t\t\t\tInfo: \"Internal server error, closing connection.\",\n\t\t\t})\n\n\t\t\tstack := debug.Stack()\n\t\t\tc.s.ErrorLog.Printf(\"panic serving %v: %v\\n%s\", c.Info().RemoteAddr, r, stack)\n\n\t\t\terr = fmt.Errorf(\"%v\", r)\n\t\t}\n\t}()\n\n\t// Send greeting\n\tif err := c.greet(); err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tif c.ctx.State == imap.LogoutState {\n\t\t\treturn nil\n\t\t}\n\n\t\tvar res *imap.StatusResp\n\t\tvar up Upgrader\n\n\t\tfields, err := c.ReadLine()\n\t\tif err == io.EOF || c.ctx.State == imap.LogoutState {\n\t\t\treturn nil\n\t\t}\n\t\tc.setDeadline()\n\n\t\tif err != nil {\n\t\t\tif imap.IsParseError(err) {\n\t\t\t\tres = &imap.StatusResp{\n\t\t\t\t\tType: imap.StatusRespBad,\n\t\t\t\t\tInfo: err.Error(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc.s.ErrorLog.Println(\"cannot read command:\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tcmd := &imap.Command{}\n\t\t\tif err := cmd.Parse(fields); err != nil {\n\t\t\t\tres = &imap.StatusResp{\n\t\t\t\t\tTag:  cmd.Tag,\n\t\t\t\t\tType: imap.StatusRespBad,\n\t\t\t\t\tInfo: err.Error(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar err error\n\t\t\t\tres, up, err = c.handleCommand(cmd)\n\t\t\t\tif err != nil {\n\t\t\t\t\tres = &imap.StatusResp{\n\t\t\t\t\t\tTag:  cmd.Tag,\n\t\t\t\t\t\tType: imap.StatusRespBad,\n\t\t\t\t\t\tInfo: err.Error(),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif res != nil {\n\n\t\t\tif err := c.WriteResp(res); err != nil {\n\t\t\t\tc.s.ErrorLog.Println(\"cannot write response:\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif up != nil && res.Type == imap.StatusRespOk {\n\t\t\t\tif err := up.Upgrade(c.conn); err != nil {\n\t\t\t\t\tc.s.ErrorLog.Println(\"cannot upgrade connection:\", err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *conn) WaitReady() {\n\tc.upgrade <- true\n\tc.Conn.WaitReady()\n}\n\nfunc (c *conn) commandHandler(cmd *imap.Command) (hdlr Handler, err error) {\n\tnewHandler := c.s.Command(cmd.Name)\n\tif newHandler == nil {\n\t\terr = errors.New(\"Unknown command\")\n\t\treturn\n\t}\n\n\thdlr = newHandler()\n\terr = hdlr.Parse(cmd.Arguments)\n\treturn\n}\n\nfunc (c *conn) handleCommand(cmd *imap.Command) (res *imap.StatusResp, up Upgrader, err error) {\n\thdlr, err := c.commandHandler(cmd)\n\tif err != nil {\n\t\treturn\n\t}\n\n\thdlrErr := hdlr.Handle(c.conn)\n\tif statusErr, ok := hdlrErr.(*imap.ErrStatusResp); ok {\n\t\tres = statusErr.Resp\n\t} else if hdlrErr != nil {\n\t\tres = &imap.StatusResp{\n\t\t\tType: imap.StatusRespNo,\n\t\t\tInfo: hdlrErr.Error(),\n\t\t}\n\t} else {\n\t\tres = &imap.StatusResp{\n\t\t\tType: imap.StatusRespOk,\n\t\t}\n\t}\n\n\tif res != nil {\n\t\tres.Tag = cmd.Tag\n\n\t\tif res.Type == imap.StatusRespOk && res.Info == \"\" {\n\t\t\tres.Info = cmd.Name + \" completed\"\n\t\t}\n\t}\n\n\tup, _ = hdlr.(Upgrader)\n\treturn\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- server/conn.go	(revision 9b2bf5c1a523d08deeb7e3cd20fdcf66b75ea82f)
+++ server/conn.go	(date 1605208283531)
@@ -243,7 +243,7 @@
 	}
 
 	greeting := &imap.StatusResp{
-		// Type:      imap.StatusRespOk,
+		Type: imap.StatusRespOk,
 		Code: imap.CodeCapability,
 		// Arguments: args,
 		// Info:      "IMAP4rev1 Service Ready",
